# Obsolete, keeping as reference and archival only

using. /Verse.org/Random

using. MathFeatures
using. VerseFeatures

StringManipulation<public> := module {

    uppercase_alphabet_characters_range<public>(CharCode:int)<computes><decides>:int = CharCode >= 65 and CharCode <= 90
    lowercase_alphabet_characters_range<public>(CharCode:int)<computes><decides>:int = CharCode >= 97 and CharCode <= 122
    alphabet_leters_characters_range<public>(CharCode:int)<computes><decides>: int = {
        uppercase_alphabet_characters_range[CharCode] or
        lowercase_alphabet_characters_range[CharCode]
    }
    uppercase_special_characters_range<public>(CharCode:int)<computes><decides>:int = {
        CharCode = 140 or
        CharCode = 159 or
        CharCode >= 192 and CharCode <= 214 or
        CharCode >= 216 and CharCode <= 222
    }
    lowercase_special_characters_range<public>(CharCode:int)<computes><decides>:int = {
        CharCode = 156 or
        CharCode >= 224 and CharCode <= 246 or
        CharCode >= 248 and CharCode <= 255
    }
    special_characters_range<public>(CharCode:int)<computes><decides>:int = {
        uppercase_special_characters_range[CharCode] or
        lowercase_special_characters_range[CharCode]
    }
    symbol_characters_range<public>(CharCode:int)<computes><decides>:int = {
        CharCode >= 33 and CharCode <= 47 or
        CharCode >= 58 and CharCode <= 64 or
        CharCode >= 91 and CharCode <= 96 or
        CharCode >= 123 and CharCode <= 126
    }

    # WIP CHANGE LATER TO A SINGLE TABLE
    # WIP USE HEX INSTEAD OF INT
    # UTF-8 Code Units Tables (One Byte)
    ControlCharacters<public>:[char]int = map{
        0o00 => 0x00, 0o01 => 0x01, 0o02 => 0x02, 0o03 => 0x03, 0o04 => 0x04, 0o05 => 0x05, 0o06 => 0x06, 0o07 => 0x07,
        0o08 => 0x08, 0o09 => 0x09, 0o0a => 0x0a, 0o0b => 0x0b, 0o0c => 0x0c, 0o0d => 0x0d, 0o0e => 0x0e, 0o0f => 0x0f,
        0o10 => 0x10, 0o11 => 0x11, 0o12 => 0x12, 0o13 => 0x13, 0o14 => 0x14, 0o15 => 0x15, 0o16 => 0x16, 0o17 => 0x17,
        0o18 => 0x18, 0o19 => 0x19, 0o1a => 0x1a, 0o1b => 0x1b, 0o1c => 0x1c, 0o1d => 0x1d, 0o1e => 0x1e, 0o1f => 0x1f
    }

    PrintableCharacters<public>:[char]int = map{
        0o20 => 0x20, 0o21 => 0x21, 0o22 => 0x22, 0o23 => 0x23, 0o24 => 0x24, 0o25 => 0x25, 0o26 => 0x26, 0o27 => 0x27,
        0o28 => 0x28, 0o29 => 0x29, 0o2a => 0x2a, 0o2b => 0x2b, 0o2c => 0x2c, 0o2d => 0x2d, 0o2e => 0x2e, 0o2f => 0x2f,
        0o30 => 0x30, 0o31 => 0x31, 0o32 => 0x32, 0o33 => 0x33, 0o34 => 0x34, 0o35 => 0x35, 0o36 => 0x36, 0o37 => 0x37,
        0o38 => 0x38, 0o39 => 0x39, 0o3a => 0x3a, 0o3b => 0x3b, 0o3c => 0x3c, 0o3d => 0x3d, 0o3e => 0x3e, 0o3f => 0x3f,
        0o40 => 0x40, 0o41 => 0x41, 0o42 => 0x42, 0o43 => 0x43, 0o44 => 0x44, 0o45 => 0x45, 0o46 => 0x46, 0o47 => 0x47,
        0o48 => 0x48, 0o49 => 0x49, 0o4a => 0x4a, 0o4b => 0x4b, 0o4c => 0x4c, 0o4d => 0x4d, 0o4e => 0x4e, 0o4f => 0x4f,
        0o50 => 0x50, 0o51 => 0x51, 0o52 => 0x52, 0o53 => 0x53, 0o54 => 0x54, 0o55 => 0x55, 0o56 => 0x56, 0o57 => 0x57,
        0o58 => 0x58, 0o59 => 0x59, 0o5a => 0x5a, 0o5b => 0x5b, 0o5c => 0x5c, 0o5d => 0x5d, 0o5e => 0x5e, 0o5f => 0x5f,
        0o60 => 0x60, 0o61 => 0x61, 0o62 => 0x62, 0o63 => 0x63, 0o64 => 0x64, 0o65 => 0x65, 0o66 => 0x66, 0o67 => 0x67,
        0o68 => 0x68, 0o69 => 0x69, 0o6a => 0x6a, 0o6b => 0x6b, 0o6c => 0x6c, 0o6d => 0x6d, 0o6e => 0x6e, 0o6f => 0x6f,
        0o70 => 0x70, 0o71 => 0x71, 0o72 => 0x72, 0o73 => 0x73, 0o74 => 0x74, 0o75 => 0x75, 0o76 => 0x76, 0o77 => 0x77,
        0o78 => 0x78, 0o79 => 0x79, 0o7a => 0x7a, 0o7b => 0x7b, 0o7c => 0x7c, 0o7d => 0x7d, 0o7e => 0x7e, 0o7f => 0x7f
    }

    ExtendedCharacters<public>:[char]int = map{
        0o80 => 0x80, 0o81 => 0x81, 0o82 => 0x82, 0o83 => 0x83, 0o84 => 0x84, 0o85 => 0x85, 0o86 => 0x86, 0o87 => 0x87,
        0o88 => 0x88, 0o89 => 0x89, 0o8a => 0x8a, 0o8b => 0x8b, 0o8c => 0x8c, 0o8d => 0x8d, 0o8e => 0x8e, 0o8f => 0x8f,
        0o90 => 0x90, 0o91 => 0x91, 0o92 => 0x92, 0o93 => 0x93, 0o94 => 0x94, 0o95 => 0x95, 0o96 => 0x96, 0o97 => 0x97,
        0o98 => 0x98, 0o99 => 0x99, 0o9a => 0x9a, 0o9b => 0x9b, 0o9c => 0x9c, 0o9d => 0x9d, 0o9e => 0x9e, 0o9f => 0x9f,
        0oa0 => 0xa0, 0oa1 => 0xa1, 0oa2 => 0xa2, 0oa3 => 0xa3, 0oa4 => 0xa4, 0oa5 => 0xa5, 0oa6 => 0xa6, 0oa7 => 0xa7,
        0oa8 => 0xa8, 0oa9 => 0xa9, 0oaa => 0xaa, 0oab => 0xab, 0oac => 0xac, 0oad => 0xad, 0oae => 0xae, 0oaf => 0xaf,
        0ob0 => 0xb0, 0ob1 => 0xb1, 0ob2 => 0xb2, 0ob3 => 0xb3, 0ob4 => 0xb4, 0ob5 => 0xb5, 0ob6 => 0xb6, 0ob7 => 0xb7,
        0ob8 => 0xb8, 0ob9 => 0xb9, 0oba => 0xba, 0obb => 0xbb, 0obc => 0xbc, 0obd => 0xbd, 0obe => 0xbe, 0obf => 0xbf,
        0oc0 => 0xc0, 0oc1 => 0xc1, 0oc2 => 0xc2, 0oc3 => 0xc3, 0oc4 => 0xc4, 0oc5 => 0xc5, 0oc6 => 0xc6, 0oc7 => 0xc7,
        0oc8 => 0xc8, 0oc9 => 0xc9, 0oca => 0xca, 0ocb => 0xcb, 0occ => 0xcc, 0ocd => 0xcd, 0oce => 0xce, 0ocf => 0xcf,
        0od0 => 0xd0, 0od1 => 0xd1, 0od2 => 0xd2, 0od3 => 0xd3, 0od4 => 0xd4, 0od5 => 0xd5, 0od6 => 0xd6, 0od7 => 0xd7,
        0od8 => 0xd8, 0od9 => 0xd9, 0oda => 0xda, 0odb => 0xdb, 0odc => 0xdc, 0odd => 0xdd, 0ode => 0xde, 0odf => 0xdf,
        0oe0 => 0xe0, 0oe1 => 0xe1, 0oe2 => 0xe2, 0oe3 => 0xe3, 0oe4 => 0xe4, 0oe5 => 0xe5, 0oe6 => 0xe6, 0oe7 => 0xe7,
        0oe8 => 0xe8, 0oe9 => 0xe9, 0oea => 0xea, 0oeb => 0xeb, 0oec => 0xec, 0oed => 0xed, 0oee => 0xee, 0oef => 0xef,
        0of0 => 0xf0, 0of1 => 0xf1, 0of2 => 0xf2, 0of3 => 0xf3, 0of4 => 0xf4, 0of5 => 0xf5, 0of6 => 0xf6, 0of7 => 0xf7,
        0of8 => 0xf8, 0of9 => 0xf9, 0ofa => 0xfa, 0ofb => 0xfb, 0ofc => 0xfc, 0ofd => 0xfd, 0ofe => 0xfe, 0off => 0xff
    }

    AllCharacters<public>:[char]int = ConcatenateMaps(ConcatenateMaps(ControlCharacters, PrintableCharacters), ExtendedCharacters)

    ToUpperCase<public>(String:string, ?IgnoreSpecialChars:logic=false)<transacts>:string = {
        CaseSwapperHandler(
            String,
            lowercase_alphabet_characters_range,
            lowercase_special_characters_range,
            -32,
            map{ 156 => 140, 255 => 159 },
            ?IgnoreSpecialChars := IgnoreSpecialChars
        )
    }

    ToLowerCase<public>(String:string, ?IgnoreSpecialChars:logic=false)<transacts>:string = {
        CaseSwapperHandler(
            String,
            uppercase_alphabet_characters_range,
            uppercase_special_characters_range,
            32,
            map{ 140 => 156, 159 => 255 },
            ?IgnoreSpecialChars := IgnoreSpecialChars
        )
    }
    
    CaseSwapperHandler<internal>(
        String:string,
        AlphabetCharsCaseRange:type{_(CharCode:int)<computes><decides>:int},
        SpecialCharsCaseRange:type{_(CharCode:int)<computes><decides>:int},
        PrintableCharsDelta:int,
        ExtendedCharsSwapMap:[int]int,
        ?IgnoreSpecialChars:logic=false
    )<transacts>:string = {
        if (String.Length <= 0). return ""

        var ResultingString : string = ""

        for (Character : String) {

            NewCharString := if (CharCode := PrintableCharacters[Character], AlphabetCharsCaseRange[CharCode]) {
                PrintableCharacters.FindKeyByValue[CharCode + PrintableCharsDelta] or Err("Unreachable")
            } else if (not IgnoreSpecialChars?, CharCode := ExtendedCharacters[Character], SpecialCharsCaseRange[CharCode]) {
                SwappedCharCode := ExtendedCharsSwapMap[CharCode] or CharCode + PrintableCharsDelta
                ExtendedCharacters.FindKeyByValue[SwappedCharCode] or Err("Unreachable") 
            } else. Character

            set ResultingString += array{NewCharString}
        }

        ResultingString
    }

    GetRandomString<public>(Length:int, ?UseNumbers:logic=false, ?UseSymbols:logic=false, ?UseSpecialChars:logic=false)<transacts>:string = {
        if (Length <= 0). return ""

        var ResultingString : string = ""

        var ValidCharacters : []char = PrintableCharacters.FindKeysByValueData[alphabet_characters_range] or Err("Unreachable")
        
        if (UseNumbers?). set ValidCharacters += PrintableCharacters.FindKeysByValueData[digit_characters_range] or Err("Unreachable")
        if (UseSymbols?). set ValidCharacters += PrintableCharacters.FindKeysByValueData[symbol_characters_range] or Err("Unreachable")
        if (UseSpecialChars?). set ValidCharacters += ExtendedCharacters.FindKeysByValueData[special_characters_range] or Err("Unreachable")
            
        ValidCharactersLength := ValidCharacters.Length
        
        var ShuffledValidCharacters : []char = Shuffle(ValidCharacters)

        var IterationIndex : int = 0
        loop {
            if (IterationIndex >= Abs(Length)). break
            
            CurrentIndex := Mod[IterationIndex, ValidCharactersLength] or Err("Unreachable")

            set ResultingString += array{ShuffledValidCharacters[CurrentIndex]} or Err("Unreachable")

            if (CurrentIndex >= ValidCharactersLength - 1){
                set ShuffledValidCharacters = Shuffle(ValidCharacters)
            }

            set IterationIndex += 1
        }

        ResultingString
    }

    SimpleStringHash<public>(String:string)<transacts>:int = {
        if (String.Length <= 0). return 0

        var ResultingHash : int = 0

        for (Char : String) {
            CharString := "{Char}"
            CharCode := ControlCharacters[CharString] or PrintableCharacters[CharString] or ExtendedCharacters[CharString] or -1
            HashedChar := ResultingHash * 31 + CharCode
            set ResultingHash = Mod[HashedChar, Constants.Max32BitInt] or Err("Unreachable")
        }

        ResultingHash
    }

    GeneratePseudoUniqueID<public>(?SaltCount:int=16)<transacts>:int = {
        UniqueStringID := "{GetSecondsSinceEpoch()}{GetRandomString(SaltCount, ?UseNumbers:=true, ?UseSymbols:=true)}{GetRandomFloat(-1024.0, 1024.0)}"
        HashedString := SimpleStringHash(UniqueStringID)
    }

    CharToIntMap<public>:[char]int = map{
        '0' => 0, '1' => 1, '2' => 2, '3' => 3, '4' => 4,
        '5' => 5, '6' => 6, '7' => 7, '8' => 8, '9' => 9
    }

    # Tries to convert a numeric string to integer
    # Fails if the string is empty or not a valid integer number
    ParseInt<public>(String:string)<decides><transacts>:int = {
        String.Length > 0
        
        var IntegerNumber:int = 0

        IsNegative := if (String[0] = '-') { true } else { false }

        for (Index->Char : String) {
            if (Index > 0 or not IsNegative?) {
                CurrentDigit := CharToIntMap[Char]
                set IntegerNumber = IntegerNumber * 10 + CurrentDigit
            }
        }

        if (IsNegative?). IntegerNumber * -1 else. IntegerNumber
    }

    # Tries to convert a numeric string to float (Including Inf and NaN values)
    # Fails if the string is empty or not a valid float number
    # If Strict is set to true, will force a fail if the resulting value is Inf or NaN
    ParseFloat<public>(String:string, ?Strict:logic=false)<decides><transacts>:float = {
        String.Length > 0

        var FloatNumber:float = 0.0
        var IsFractionPart:logic = false
        var FractionDivider:float = 1.0

        IsNegative := if (String[0] = '-') { true } else { false }

        if (String = "-Inf" or String = "Inf") {
            not Strict?
            set FloatNumber = Inf
        } else if (String = "NaN") {
            not Strict?
            set FloatNumber = NaN
        } else {
            for (Index->Char : String) {
                if (Index > 0 or not IsNegative?) {
                    if (Char = '.') {
                        set IsFractionPart = true
                    } else {

                        CurrentDigit := CharToIntMap[Char]

                        if (IsFractionPart?) {
                            set FractionDivider *= 10.0
                            set FloatNumber += CurrentDigit * 1.0 / FractionDivider
                        } else {
                            set FloatNumber = FloatNumber * 10.0 + CurrentDigit * 1.0
                        }
                    }
                }
            }
        }

        if (IsNegative?). FloatNumber * -1.0 else. FloatNumber
    }
}
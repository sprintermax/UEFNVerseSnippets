using. MathFeatures

# BinarySearch searches for target in a sorted slice and returns the earliest
# position where target is found, or the position where target would appear
# in the sort order; it also returns a bool saying whether the target is
# really found in the slice. The slice must be sorted in increasing order.
# NOTE: USING CUSTOM VERSE IMPLEMENTATION, NOT GOLANG IMPLEMENTATION DUE TO LACK OF BIT SHIFTING
# WARNING: PASSING UNSORTED SLICES TO THIS FUNCTION LEADS TO UNDEFINED AND UNRELIABLE BEHAVIOR.
(Input:[]int).BinarySearch<public>(Target:int)<transacts>:tuple(int, logic) = {
    (for (Element : Input). Element * 1.0).BinarySearch(Target * 1.0)
}

(Input:[]float).BinarySearch<public>(Target:float)<transacts>:tuple(int, logic) = {
    Length := Input.Length
    # Define x[-1] < target and x[n] >= target.
	# Invariant: x[i-1] < target, x[j] >= target.
    var I : int = 0
    var J : int = Length

    loop {
        I < J or (break)

        H := ((I + J) / 2).Truncate() or Err("Unreachable")

        Cmp.LessFloat[Input[H], Target] and (set I = H + 1) or (set J = H)
    }

    (I, logic{I < Length and (Input[I] = Target or (not Input[I].IsFinite[] and not Target.IsFinite[]))})
}

# BinarySearchFunc works like [BinarySearch], but uses a custom comparison
# function. The slice must be sorted in increasing order, where "increasing"
# is defined by cmp. cmp should return 0 if the slice element matches
# the target, a negative number if the slice element precedes the target,
# or a positive number if the slice element follows the target.
# cmp must implement the same ordering as the slice, such that if
# cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.
# NOTE: USING CUSTOM VERSE IMPLEMENTATION, NOT GOLANG IMPLEMENTATION DUE TO LACK OF BIT SHIFTING
# WARNING: PASSING UNSORTED SLICES TO THIS FUNCTION LEADS TO UNDEFINED AND UNRELIABLE BEHAVIOR.
(Input:[]t).BinarySearchDynamic<public>(Condition:type{_(:t, :t2)<decides><transacts>:void}, ConditionArgs:t2 where t:type, t2:type)<transacts>:tuple(int, logic) = {
    Length := Input.Length
    # Define cmp(x[-1], target) < 0 and cmp(x[n], target) >= 0 .
	# Invariant: cmp(x[i - 1], target) < 0, cmp(x[j], target) >= 0.
    var I : int = 0
    var J : int = Length

    loop {
        I < J or (break)

        H := ((I + J) / 2).Truncate() or Err("Unreachable")

        Condition[Input[H], ConditionArgs] and (set I = H + 1) or (set J = H)
    }

    (I, logic{I < Length and Condition[Input[I], ConditionArgs]})
}